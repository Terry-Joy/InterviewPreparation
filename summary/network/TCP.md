# TCP协议详解
## 1.TCP特点
+ TCP是一种面向连接的可靠的字节流的协议。是基于IP的传输层协议。面向连接意味着两个使用TCP的应用交换数据前，必须先建立TCP连接。
+ TCP连接是全双工，数据读写可以通过一个连接进行。
+ TCP连接是端对端的，所以广播和多播（一对多）的应用不能用TCP服务，大多用UDP。
+ 发送端执行的写操作次数和接收端的读操作次数之间无数量关系，即字节流的概念，应用程序对数据的发送和接收是没有边界限制的。


## 2.TCP头部
头部各端口号说明
+ **源、目标端口号字段**：占16比特。TCP协议通过使用”端口”来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，操作系统动态地为客户端的应用程序分配端口号。在服务器端，每种服务在”众所周知的端口”（Well-Know Port）为用户提供服务。
+ 顺序号字段：占32比特。用来标识从TCP源端向TCP目标端发送的数据字节流，它表示在这个报文段中的第一个数据字节。在建立TCP连接的时候，随机初始化ISN。
+ 确认号字段：占32比特。只有ACK标志为1时，确认号字段才有效。它包含目标端所期望收到源端的下一个数据字节。
+ 头部长度字段：占4比特。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。
+ URG:　　当 URG=1 时,表明紧急指针字段有效.它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据)
+ ACK:　　只有当 ACK=1 时确认号字段才有效.当 ACK=0 时,确认号无效
+ PSH(PuSH):　提示接收端应用程序尽快地交付接收应用进程,而不再等到整个缓存都填满了后再向上交付
+ RST (ReSeT):　　当 RST=1 时,表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）,必须释放连接,然后再重新建立运输连接
+ 同步 SYN:　　同步 SYN = 1 表示这是一个连接请求或连接接受报文
+ 终止 FIN:　　用来释放一个连接.FIN=1 表明此报文段的发送端的数据已发送完毕,并要求释放运输连接
+ TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。
+ 紧急指针字段：占16比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。
+ 其他选项:
	+ 窗口扩大:　　占 3 字节,其中有一个字节表示移位值 S.新的窗口值等于TCP 首部中的窗口位数增大到(16 + S),相当于把窗口值向左移动 S 位后获得实际的窗口大小
	+ 时间戳:　　占10 字节,其中最主要的字段时间戳值字段(4字节)和时间戳回送回答字段(4字节)
	+ （SACK）选择确认: 使TCP模块只重传已经丢失的TCP报文段。

单位：TCP报文段

## 3.TCP三次握手
TCP是面向连接的协议，一方向另一方发送数据之前，都必须先在双方间建立一条连接。
+ 开始，客户端和服务端都处于 CLOSED 状态。先是服务端监听某个端口，处于 LISTEN 状态
+ **第一次握手**：客户端会随机初始化序号（ client_isn ），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。
+ **第二次握手**, 服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（ server_isn ），将此序号填入TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1 , 接着把 SYN和 ACK 标志位置为 1 。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。
+ **第三次握手**，客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。
+ 服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。

**（ISN）是固定的吗**
三次握⼿的⼀个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以让对⽅知道接下来接收数据的时候如何按序列号组装数据。如果ISN是固定的，攻击者很容易易猜出后续的确认号，因此 ISN 是动态⽣生成的
**（1）什么是半连接队列** （SYN queue, accept queue)
服务器第⼀次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双⽅还没有完全建⽴其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有⼀个全连接队列，就是已经完成三次握手时，会把半连接队列中的TCP信息放入全连接队列中，如果队列满了了就有可能会出现丢包现象。

**（2）SYN-ACK 重传次数的问题：**
服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进⾏首次重传，等待一段时间仍未收到客户确认包，进⾏第⼆次重传，如果重传次数超过系统规定的最⼤重传次数，系统将该连接信息从半连接队列中删除。每次重传的时间间隔不同的，linux下默认5次，1，2，4，8，16，再等32秒，总共63秒断开。

**（3）三次握⼿手过程中可以携带数据吗**
第三次握⼿手的时候，是可以携带数据的（RFC标准）。假如第一次可以携带，在SYN报文中放入大量数据，攻击服务器，不安全。⽽对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据⻚没啥⽑病。	

**（4）为什么不能两次握手解决**
1.防止重复的已经失效的历史连接的初始化，节省资源。假如只有两次握手，客户端之前发送的一个网络包由于延迟未到达，客户端重传新的SYN报文并完成了连接与传输数据的过程，进入closed状态，这时旧的连接到达服务器，由于只用两次握手，服务器就会发出确认，并且建立连接，但是客户端不理睬他，服务器一直等待客户端数据，浪费了资源。
2.同步双方初始序列号，保证可靠传输。序列号是可靠运输的关键因素，可以让接收方去除重复的数据，按序接收数据包，知道已经发出去的数据包，哪些被收到了。假如是两次握手，第二次握手确认了服务器端知道了客户端的初始序列号，而我们还需要一次握手，表明客户端确认了服务器初始序列号。

## 4.TCP四次挥手
刚开始两者都在established状态，
+ 第一次挥手：假如当客户端想关闭连接的时候，发送一个FIN报文给服务器端，同时指定自己的序号，然后进入FIN_WAIT1状态。
+ 第二次挥手：服务器接收到FIN报文后，发送一个ACK报文给客户端，同时指明自己的序列号，还指明自己的确认序列号为客户端序列号+1，发送后进入close_wait状态。
+ 在close_wait状态下，服务器仍能发送数据给客户端，直到所有数据传输完成，服务器端想关闭连接了，第三次挥手：发送一个FIN报文给客户端，且指定一个序列号，此时服务器进入Last_ACK状态。
+ 第四次挥手：客户端受到FIN报文段后，发送一个ACK报文段，确认序列号为服务器序列号+1，然后进入TIME_WAIT状态。
+ 服务器收到ACK报文段之后，进入CLOSED状态，服务器端连接完成关闭
+ 客户端经过2MSL一段时间后，进入CLOSED状态，客户端连接完成关闭

【注意是：主动关闭连接的，才有 TIME_WAIT 状态。】

## 5.讲述下TIME_WAIT状态
TIME_WAIT状态有两个作用，
+ 用于确认客户端对服务器FIN报文的确认是否被服务器接收，使得连接正确关闭。等待时间是2MSL，即2个报文最大生存时间，，假如网络环境不好，客户端ACK发送到服务器端是1MSL，服务器端没收到触发超时重传机制重新发送FIN报文段，也是一个MSL，所以来回两个MSL，假如客户端在2MSL过程中没再收到服务器端的信息，说明服务器端已经收到了客户端的确认报文段，则客户端连接可以关闭。
+ 保证一些延迟的数据包被送至客户端，自然消失。（再次开启连接接收过期数据包，数据错乱）
**TIME_WAIT时间过长过短的问题看**
https://www.zhihu.com/question/271701044/answer/1279809269

在 Linux 系统里 2MSL 默认是 60 秒，那么一个 MSL 也就是 30 秒。Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒。



**TTL与MSL**
MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡。

## 流量控制
TCP提供流量控制服务，为了防止因为发送方发送速率过快导致接收方缓存溢出，（速度匹配，使发送速度和接收速度匹配）。流量控制是通过滑动窗口机制实现的，接收方和发送方都维护一个接收窗口，对于接收方来说，要保证最后一个从缓存中读出的字节减去已放入接收缓存的最后一个字节的大小要小于等于接收方的缓存大小，缓存减去已用的缓存空间剩余的就是接收窗口的大小，接收方会定期把接收窗口的大小写入报文段中发给发送方，告诉发送方还有多少可用空间，发送方要做得就是保证最后一个发送的字节编号减去最后一个发送的被确认的编号的大小要小于等于接收方的接收窗口。当接收窗口大小为0时，发送方还会发送一个只有一个字节数据的报文段，接收方会清空缓存并且返回一个新的接收窗口大小给发送方。
