## 1.OSI七层模型及其主要功能
[![Hj86ud.png](https://s4.ax1x.com/2022/02/21/Hj86ud.png)](https://imgtu.com/i/Hj86ud)

+ 应用层：为用户的应用进程提供网络通信服务。在互联网中的应用层协议很多，如域名系统DNS、HTTP协议、SMTP协议等。
+ 表示层：处理用户信息的表示问题，数据的编码，压缩和解压缩，数据的加密和解密
+ 会话层：负责在网络中的两节点之间建立、维持和终止通信
+ 传输层：负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。
+ 网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括$IP,ICMP$协议。
+ 数据链路层：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的$ IP$ 数据报组装成帧，在两个相邻节点间的链路上传送帧。
+ 物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异。


## 2.ARP协议及其工作原理
### ARP协议
在网络层上方使用$IP$地址标识主机，但在数据链路层我们需要用知道主机的硬件地址(MAC地址)。

ARP是IPv4协议中实现从$IP$地址向物理地址的动态映射。(IPv6 使用邻居发现协议，ICMPv6中)

### ARP协议工作原理
每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。
+ 当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，(ff:ff:ff:ff:ff:ff), 查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。
+ 网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。
+ 源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。
+ 如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。
(如果本地网段无法查询，则通过网关路由表向外查询)#

## 3.RARP协议及其工作原理

反向地址转换协议，网络层协议，RARP与ARP工作方式相反。 RARP使只知道自己硬件地址的
主机能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所
需信息的RARP服务器发出的IP地址。
原理：
(1)网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网
卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求**RARP服务器**回复该主机的
IP地址。
(2)RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP响应发送给主机。
(3)PC1收到RARP回应后，就使用得到的IP地址进行通讯。

## 4.简述DNS
DNS是域名系统，是一个分布式的数据库。用于将主机名和域名转换为$IP$地址的工作。
DNS采取树状层次域名结构，分级自上而下分别为根域名、顶级域名、二级域名、三级域名。
域名服务器自上而下分为根域名服务器，顶级域名服务，权限域名服务器。

## 5.DNS解析过程
+ 从浏览器缓存中查找，找到直接返回IP
+ 没有，找操作系统hosts文件和本地DNS解析器缓存
+ 仍没有，就将域名发送到本地域名服务器(由ISP管理)去请求，这个过程也就是"递归查询"，本地域名服务器查询自己DNS缓存寻找对应域名，(多级缓存机制，从www.baidu.com -> com，没问到别答)，有就返回，都没有依次就向根域名服务器，顶级域名服务器，权威域名服务器进行迭代查询。（本地DNS服务器通过端口53）具体来讲就是根服务器查询对应域名有IP地址，若有就返回IP，否则就返回对应下一级域名服务器的地址，本地域名服务器会继续查询，以此类推，最后返回IP地址给本地域名服务器
+ 本地域名服务器缓存该IP地址和域名，同时返回IP地址给主机
+ 主机操作系统将IP返回给浏览器
+ 浏览器得到域名对应IP地址并缓存

**UDP传输**

## 6.谈谈你对域名缓存的了了解？
DNS服务器上使用高速缓存，⽤来存放最近查询过的域名以及从何处获得域名映射信息的记录。本质是为了提⾼ DNS 查询效率，减轻服务器的负荷和减少因特⽹上的 DNS 查询报⽂。由于名字到地址的绑定并不经常改变，为保持⾼速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项。当域名服务器器已从缓存中删去某项信息后⼜被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权威服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少⽹网络开销，⽽而减少此时间值可提⾼高域名解析的正确性。
不不仅在本地域名服务器器中需要⾼高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放⾃己最近使用的域名的⾼速缓存，并且只在从缓存中找不不到名字时才使⽤域名服务器器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，⽽且主机必须从缓存中删除无效的项。
由于域名改动并不不频繁，⼤多数网点不不需花精力就能维护数据库的⼀致性。

## IP协议相关
+ ip地址分类
+ ip地址和mac地址区别
+ 子网划分、子网掩码
+ ICMP协议
+ 局域网、广域网

## 7.TCP三次握手
[![bP8YCj.png](https://s4.ax1x.com/2022/02/23/bP8YCj.png)](https://imgtu.com/i/bP8YCj)
TCP是面向连接的协议，一方向另一方发送数据之前，都必须先在双方间建立一条连接。
+ 开始，客户端和服务端都处于 CLOSED 状态。先是服务端监听某个端口，处于 LISTEN 状态
+ **第一次握手**：客户端会随机初始化序号（ client_isn ），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。
+ **第二次握手**, 服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（ server_isn ），将此序号填入TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1 , 接着把 SYN和 ACK 标志位置为 1 。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。
+ **第三次握手**，客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。
+ 服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。

**（ISN）是固定的吗**
三次握⼿的⼀个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以让对⽅知道接下来接收数据的时候如何按序列号组装数据。如果ISN是固定的，攻击者很容易易猜出后续的确认号，因此 ISN 是动态⽣生成的
**（1）什么是半连接队列** （SYN queue, accept queue)
TCP三次握手时，linux内核维护两个队列
+ 半连接队列
+ 全连接队列
服务器第⼀次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双⽅还没有完全建⽴其连接，服务器会把此种状态下连接放在一个队列里，我们把这种队列称之为半连接队列。当完成三次握手时，会把半连接队列中的TCP信息放入全连接队列中，如果队列满了了就有可能会出现丢包现象。

**（2）SYN-ACK 重传次数的问题：**
服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进⾏首次重传，等待一段时间仍未收到客户确认包，进⾏第⼆次重传，如果重传次数超过系统规定的最⼤重传次数，系统将该连接信息从半连接队列中删除。每次重传的时间间隔不同的，linux下默认5次，1，2，4，8，16，再等32秒，总共63秒断开。

**（3）三次握⼿手过程中可以携带数据吗**
第三次握⼿手的时候，是可以携带数据的（RFC标准）。假如第一次可以携带，在SYN报文中放入大量数据，攻击服务器，不安全。⽽对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据⻚没啥⽑病。	

**（4）为什么不能两次握手解决**
1.防止重复的已经失效的历史连接的初始化，节省资源。假如只有两次握手，客户端之前发送的一个网络包由于延迟未到达，客户端重传新的SYN报文并完成了连接与传输数据的过程，进入closed状态，这时旧的连接到达服务器，由于只用两次握手，服务器就会发出确认，并且建立连接，但是客户端不理睬他，服务器一直等待客户端数据，浪费了资源。
2.同步双方初始序列号，保证可靠传输。序列号是可靠运输的关键因素，可以让接收方去除重复的数据，按序接收数据包，知道已经发出去的数据包，哪些被收到了。假如是两次握手，第二次握手确认了服务器端知道了客户端的初始序列号，而我们还需要一次握手，表明客户端确认了服务器初始序列号。

## 8.TCP四次挥手
[![bP8N2n.png](https://s4.ax1x.com/2022/02/23/bP8N2n.png)](https://imgtu.com/i/bP8N2n)
刚开始两者都在established状态，
+ 第一次挥手：假如当客户端想关闭连接的时候，发送一个FIN报文给服务器端，同时指定自己的序号，然后进入FIN_WAIT1状态。
+ 第二次挥手：服务器接收到FIN报文后，发送一个ACK报文给客户端，同时指明自己的序列号，还指明自己的确认序列号为客户端序列号+1，发送后进入close_wait状态。
+ 在close_wait状态下，服务器仍能发送数据给客户端，直到所有数据传输完成，服务器端想关闭连接了，第三次挥手：发送一个FIN报文给客户端，且指定一个序列号，此时服务器进入Last_ACK状态。
+ 第四次挥手：客户端受到FIN报文段后，发送一个ACK报文段，确认序列号为服务器序列号+1，然后进入TIME_WAIT状态。
+ 服务器收到ACK报文段之后，进入CLOSED状态，服务器端连接完成关闭
+ 客户端经过2MSL一段时间后，进入CLOSED状态，客户端连接完成关闭

【注意是：主动关闭连接的，才有 TIME_WAIT 状态。】

**为什么要四次**
因为 TCP 是全双工协议，也就是说双方都要关闭，都要一个FIN和ACK。

## 9.讲述下TIME_WAIT状态
TIME_WAIT状态有两个作用，
+ 用于确认客户端对服务器FIN报文的确认是否被服务器接收，使得连接正确关闭。等待时间是2MSL，即2个报文最大生存时间，，假如网络环境不好，客户端ACK发送到服务器端是1MSL，服务器端没收到触发超时重传机制重新发送FIN报文段，也是一个MSL，所以来回两个MSL，假如客户端在2MSL过程中没再收到服务器端的信息，说明服务器端已经收到了客户端的确认报文段，则客户端连接可以关闭。
+ 防止具有相同四元组的旧的数据包被接收（再次开启相同连接接收过期数据包，数据错乱）

在 Linux 系统里 2MSL 默认是 60 秒，那么一个 MSL 也就是 30 秒。Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒。
**TIME_WAIT时间过长过短的问题看**
https://www.zhihu.com/question/271701044/answer/1279809269


**追问：TIME_WAIT 过多有什么危害**？
过多的 TIME-WAIT 状态主要的危害有两种：
第一是内存资源占用；
第二是对端口资源的占用，一个 TCP 连接⾄少消耗⼀个本地端口



**TTL与MSL**
MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡。

## 10.谈谈你对流量控制的理解
TCP提供流量控制服务，为了防止因为发送方发送速率过快导致接收方缓存溢出，（速度匹配，使发送速度和接收速度匹配）。流量控制是通过滑动窗口机制实现的，接收方和发送方都维护一个接收窗口，对于接收方来说，要保证最后一个从缓存中读出的字节减去已放入接收缓存的最后一个字节的大小要小于等于接收方的缓存大小，缓存减去已用的缓存空间剩余的就是接收窗口的大小，接收方会定期把接收窗口的大小写入报文段中发给发送方，告诉发送方还有多少可用空间，发送方要做得就是保证最后一个发送的字节编号减去最后一个发送的被确认的编号的大小要小于等于接收方的接收窗口。当接收窗口大小为0时，发送方还会发送一个只有一个字节数据的报文段，**（防止死锁，接收方只有有数据或者是确认报文段发送时才会告诉接收方）**，接收方会清空缓存并且返回一个确认报文段携带新的接收窗口大小给发送方。
滑动窗口为大小为0时，发送方不再发送数据，但有两种情况例外
+ 一种情况是可以发送紧急数据。例如，允许用户终止在远端机上的运行进程。
+ 另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。

## 11.谈谈你对拥塞控制的理解
网络中出现拥堵时，如果继续发送大量数据包，可能会丢包、超时重传，导致网络的负荷更重，拥塞控制就是通过控制发送方速率，防止过多的数据注入网络中，加重网络的负载。TCP发送方会维护一个拥塞窗口，该窗口的大小取决于网络的拥塞情况动态变化，发送方的发送窗口取为拥塞窗口和接收方接受窗口中较小的一个。（超时重传 or 三个冗余ACK表示拥塞）。	

TCP拥塞控制采用了四个