+ 存储引擎
	+ InnoDB
	InnoDB 是 MySQL 默认的事务型存储引擎，只要在需要它不支持的特性时，才考虑使用其他存储引擎。InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准隔离级别(未提交读、提交读、可重复读、可串行化)。其默认级别时可重复读（REPEATABLE READ），在可重复读级别下，通过 MVCC + Next-Key Locking 防止幻读。
	+ MyISAM
	 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

	提供了大量的特性，包括压缩表、空间数据索引等。

	不支持事务。

	不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

	可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

	如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。
	

**1.mysql的基础架构**
大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。而存储引擎层负责数据的存储和提取。

从图中不难看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。


**1.Mysql中的MyISAM与InnoDB的区别？**
（1）InnoDB存储引擎支持事务，而MyISAM不支持事务；

（2）InnoDB支持行级锁，而MyISAM只支持表级锁；

（ InnoDB行锁是通过给索引加锁实现的，即只有通过索引条件检索数据，InnoDB才使用行级锁，否则将使用表级锁！行级锁在每次获取锁和释放锁的操作需要比表级锁消耗更多的资源。

MySQL表级锁有两种模式：表共享读锁和表独占写锁。就是说对MyIASM表进行读操作时，它不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写操作；而对MyISAM表的写操作，会阻塞其他用户对同一表的读和写操作。）

（3）InnoDB支持外键，而MyISAM不支持外键；

（4）InnoDB支持在线热备份

（5）崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。


（ 也就是说，执行 select count(*) from table 时，InnoDB要扫描一遍整个表来计算有多少行，而MyISAM只需要读出保存好的行数即可（内部维护了一个计算器，可以直接调取）。【注】：当count(*)语句包含where条件时，两种表的操作是一样的。也就是上述介绍到的InnoDB使用表锁的一种情况。）

　　对于select ,update ,insert ,delete 操作：

　　如果执行大量的SELECT，MyISAM是更好的选择（因为MyISAM不支持事务，使得MySQL可以提供高速存储和检索，以及全文搜索能力）；

　　如果执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表（因为InnoDB支持事务，在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了）。

**3.什么是事务**
　事务就是满足ACID四大特性的一组操作序列，我们可以通过commit提交事务，也可以通过rollback来回滚。

**4.数据库事务的四大特性？**
A: 原子性：事务的操作要么都成功，要么全部失败回滚
C: 一致性：数据库在事务执行前后保持一致性状态，比如说某物品总共800份，A300， B500，A->B 200，最后总共仍是800。
I: 隔离性: 一个事务所做的修改在最终提交以前，对其他事务是不可见的。
D: 持久性：一旦事务提交，进行的修改将永远保存在数据库中。

**5.隔离级别**
+ 未提交读（READ UNCOMMITTED）
事务中的修改，即使没有提交，对其他事务也是可见的。

+ 已提交读（READ COMMITTED）
一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其他事务是不可见的。

+ 可重复读（REPEATABLE READ） （InnoDB的默认隔离级别）
保证在同一个事务中多次读取同样数据的结果是一样的。

+ 可串行化（SERIALIZABLE）
强制事务串行执行。

需要加锁实现，而其它隔离级别通常不需要。

**5.不考虑事务的隔离性，会发生几种问题？（并发一致性问题）**
通过锁可以实现事务隔离性的要求，使得事务可以并发地工作。因为事务隔离性的要求，锁会带来一些问题。


+ 丢失更新: 指一个事务的更新操作被另一个事务的更新操作所覆盖。比如T1事务先对一个数据进行修改，T1修改后，在T1还没提交的时候，T2再修改这个数据为另一个值并提交。这样导致T1只能查询到假数据，丢失了更新操作。
  **解决方案**：
+ 脏读
  一个事务读取到了另一个事务未提交的数据，那这个读取就是脏读。比如一个事务读取A，修改A，在提交前，另一个事务读取到了这个被修改的A，但是随后前一个事务回滚，导致第二个事务读取到了错误的数据。
  **解决方案**：把数据库的事务隔离级别调整到read commited
+ 不可重复读：
  同一事务内多次读取同一数据集合，在该事务还没结束时，另一个事务也访问并修改了同一数据，那么在第一个事务的两次读诗句之间，由于修改，可能导致读到的数据是不一致的。

+ 幻读:　可以看成是不可重复读的一种特殊情况，只是他针对的是数据的增删问题，而不可重复读针对的是数据的值的更新问题。例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

****

事务的四个特性->隔离性不满足->四个问题->四个隔壁级别从读已提交开始解决三个问题。

