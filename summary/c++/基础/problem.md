## 1.c++和c有什么区别？
+ C++是⾯向对象的语言，⽽C是⾯向过程的语言；
+ C++引⼊ new/delete 运算符，取代了C中的 malloc/free 库函数；
+ C++引⼊引用的概念，⽽C中没有；
+ C++引⼊类的概念，⽽C中没有；
+ C++引入函数重载的特性，⽽C中没有

## 2.数组名和指针有什么区别？
+ 数组名在函数传参的时候会变成指针，但两者差别很大
+ 数组名可以指代一种数据结构，就是数组。从sizeof可以看出，sizeof一个数组名得到的是整个数组所有元素的大小，但是sizeof一个指针，就是指针变量本身的大小。
+ 数组名取地址得到的是数组名所指向首元素的地址，对指针取地址得到的是指针变量自身的地址。
+ 数组名取地址+1，整体加了数组偏移，而指针取地址+1则是增大对应的字节。
+ 数组名可以用作一个常量指针，比如说可以*(a + 1) = a[1],但我们无法修改指向的位置，指针是一个变量。

## 3.static 有什么作用？
+ 修饰局部变量的时候，该变量在静态存储区分配内存。只有首次函数调用中会进行初始化，之后的函数调用不会进行初始化。同时该变量的生命周期和程序相同。但是作用域是局部作用域，
+ 修饰全局变量，该变量在静态存储区分配内存，在声明该变量的整个文件是可见的，但是在文件外不可见，所以别的文件也可以使用同名变量。(全局变量与全局函数的时候，文件外不可见)
+ 修饰全局函数时，该函数在声明函数的整个文件可见，但是在文件外是不可见的，可以避免多人协作的时候同名函数的冲突。
+ 修饰成员变量的时候，该变量存储在静态存储区，所有对象都持有该变量的一份拷贝，可以实现不同对象间的数据共享。该变量不需要实例化对象也可以访问，因为本质上是一个类变量。此外该变量不能在类内初始化，一般在类外初始化。
+ 修饰成员函数的时候,该函数不接受this指针，所以只能访问类的静态成员。不需要实例化对象即可访问。

## 4.define和const的区别
+ 编译器处理的方式不同：define是在预处理阶段起作用，const是在编译的阶段使用。
+ 类型和安全检查不同：define宏没有类型，只做代码展开，不进行类型检查，容易出现边际问题。而const是有数据类型的，进行类型检查。
+ 存储方式不同：define只是代码展开，在多个地方进行字符串替换，所以不分配内存，存储在程序代码段里，但是const常量会分配内存，只有一份拷贝，占用数据段空间。
+ 作用域不同：define宏是不受作用域的限制，在define后的代码都可以应用，而const常量只在作用域内有效。

RALL类模型：
将一些在使用前需要先获取的资源(堆内存，互斥锁，socket)的生命周期绑定到一个局部变量防止造成资源泄漏或死锁。
流程：
+ 把资源用类封装起来
+ 对资源的操作在类的内部
+ 在析构函数中释放资源
+ 局部变量作用域结束，析构函数自动调用

## 5.什么是智能指针？智能指针有什么作用？分为哪几种，各自有什么样的特点？
智能指针是一个RALL类模型，用于动态分配内存，基本思想是把基本类型指针封装成模板类对象指针，在离开作用域的时候调用析构函数，使用delete删除指针所指向的内存空间。

智能指针是一种模版类，能够动态分配内存，管理动态对象的模型。在变量离开作用域的时候可以自动使用delete删除指针所指向的内存空间。
智能指针能处理内存泄漏和空悬指针的问题。
+ shared_ptr，共享式指针，多个指针指向相同的对象，内部维护一个计数器，统计有多少个指针指向该对象，假如没有指针指向计数器的时候，计数变为0，自动释放与对象相关的资源，
+ unique_ptr，独占式指针，同一时间只有一个智能指针可以指向指定的对象，所以无法进行拷贝构造和拷贝赋值（计数++的都不行），但可以进行移动构造和移动赋值。
+ weak_ptr, 相当于一种弱引用，可以绑定到shared_ptr，但不会影响对象的引用计数，所以能防止shared_ptr互相引用导致的死锁问题。借助weak_ptr，可以获取shared_ptr的一些信息，比如有多少个指向对象相同的shared_ptr指针。

循环引用问题。
shared_ptr互相引用导致无法销毁
```cpp
class B;
class A{
public:
	~A(){

	}
	shared_ptr<B> pb;
}
class A {
public:
	~B(){ }
	shared_ptr<A> pa;
}

shared_ptr<A> pa(new A());
shared_ptr<B> pb(new B());
pa->pb = pb;
pb->pa = pa;
```
把其中一个智能指针换成弱引用
解决循环引用的方法：
+ 当只剩下最后一个引用的时候需要手动打破循环引用释放对象。
+ 当A的生存期超过B的生存期的时候，B改为使用一个普通指针指向A。
+ 使用弱引用的智能指针打破这种循环引用。虽然这三种方法都可行，但方法1和方法2都需要程序员手动控制，麻烦且容易出错。我们一般使用第三种方法：弱引用的智能指针weak_ptr。

但是unique_ptr允许通过函数返回给其他的unique_ptr，还可以通过std::move来转移到其他的unique_ptr，注意，这时它本身就不再拥有原来指针的所有权了。

## 6.shared_ptr是怎么实现的？
+ 构造函数中初始化计数为1。
+ 以下四种复制计数器+1
1）初始化另一个shared_ptr时；
2）作为赋值的右操作数时；
3）作为实参传递给函数；
4）从函数中按值返回时。

当给shared_ptr赋新值以及shared_ptr本身被销毁时（例如本地shared_ptr超出作用域时），计数器将递减。

一旦shared_ptr的计数器变为零（ **最后一个指向对象的shared_ptr被撤销时**），shared_ptr将通过析构函数自动释放它所管理的对象。

## 7.悬挂指针和野指针有什么区别？
+ 悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，以⾄于其仍然指向已经被回收的内存地
址，这种情况下该指针被称为悬挂指针；
+ 野指针：未初始化的指针被称为野指针。

## 8.右值引用有什么作用？
左值：可寻址的变量，具有持久性。
右值：一般是不可寻址的常量，或在表达式求值过程中创建的临时变量，短暂性的。

+ 左值引用， 使用 T&, 只能绑定左值
+ 右值引用， 使用 T&&， 只能绑定右值
+ 常量左值， 使用 const T&, 既可以绑定左值又可以绑定右值
+ 已命名的右值引用，编译器会认为是个左值
+ 编译器有返回值优化，但不要过于依赖
+ 引用折叠规则：所有的右值引用叠加到右值引用上仍然是一个右值引用，其他引用之间的折叠都为左值引用。当T&&为模板参数时，输入左值，它将变成左值引用，输入右值则变成具名的右值应用。
+ 移动语义可以减少无谓的内存拷贝，要想实现移动语义，需要实现移动构造函数和移动赋值函数。
+ std::move()将一个左值转换成一个右值，强制使用移动拷贝和赋值函数，这个函数本身并没有对这个左值什么特殊操作。
+ std::forward()和universal references通用引用（模板加上T&&）共同实现完美转发。
+ 用empalce_back()替换push_back()增加性能。

**一般左值引用无法指右值，但是const 左值引用可以**
右值引用专门为右值而生，可以指向右值，不能指向左值：
**std::move, 唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast<T&&>(lvalue)。 所以，单纯的std::move(xxx)不会有性能提升**

右值引⽤的主要⽬目的是为了实现移动语义（避免不必要的拷贝，提高性能，实现move()）和完美转发，消除两个对象交互时不必要的对象拷⻉贝，也能够更加简洁明确地定义泛型函数。
所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。

+ 从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。
+ 右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。
+ 作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。

std::vector的push_back和emplace_back。参数为左值引用意味着拷贝，为右值引用意味着移动。
Array(Array&& temp_array) {
	data_ = temp_array.data_;
	size_ = temp_array.size_;
	// 为防止temp_array析构时delete data，提前置空其data_      
	temp_array.data_ = nullptr;
}

std::forward<T>(u) 
std::forward<T>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。


## 10.静态链接和动态链接有什么区别？
+ 静态链接是在编译链接时直接将需要的执行代码拷贝到调用处；
优点在于程序在发布时不需要依赖库，可以独⽴执行，缺点在于程序的体积会相对较大，而且如果静态库更新
之后，所有可执行文件需要重新链接；
+ 动态链接是在编译时不直接拷⻉执行代码，⽽是通过记录一系列符号和参数，在程序运行或加载时将这些信息
传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执⾏代码，实现运⾏时链接；
优点在于多个程序可以共享同⼀个动态库，节省资源；缺点在于由于运行时加载，可能影响程序的前期执⾏性能。

## 11.变量的声明和定义有什么区别？
变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。⼀个变量可以在多个地方声明， 但是只在⼀个地方定义。加入extern 修饰的是变量的声明，说明此变量将在文件以外或在⽂件后面部分定义。
说明：很多时候⼀个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。

**要在多个文件中使用同一个变量，我们仅能在一个文件中定义变量，而其他用到该变量的文件必须对该变量进行声明，却不能重复定义。**
```cpp
extern int i; 
```

## 12.简述#ifdef、#else、#endif和#ifndef的作用？
条件编译命令，有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。
在头文件中使用#ifdef和＃ifndef是非常重要的，可以防止双重定义的错误。（a.h中常使用） 

## 13.结构体可以直接初始化吗？
声明时可以直接初始化，同⼀结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针“成员”时⼀定要⼩小
心。
「注意」：当有多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的⾮法操作。因此在释放
前⼀定要确保其他指针不再使用这段内存空间。

## 14.sizeof和strlen的区别？
+ sizeof是一个操作符，strlen是库函数。
+ sizeof的参数可以是数据的类型，也可以是变量，⽽strlen只能以结尾为‘\0’的字符串作参数。
+ 编译器在编译时就计算出了sizeof的结果，⽽strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的⼤小，而strlen计算的是字符串实际的长度。
+ 数组做sizeof的参数不退化，传递给strlen就退化为指针了。


## 15.volatile有什么作⽤？
告诉编译器，这是一个易变的变量。让编译器不要对修饰的变量做出假设，要按部就班的使用这个变量。比如说不要从寄存器取该变量的值，而是从原始地址取。


## 16.全局变量和局部变量有什什么区别？操作系统和编译器是怎么知道的？
+ 全局变量是整个程序都可访问的变量，谁都可以访问，⽣存期在整个程序从运行到结束（在程序结束时所占内
存释放）；
+ ⽽局部变量存在于模块（子程序，函数）中，只有所在模块可以访问，其他模块不可直接访问，模块结束（函
数调⽤用完毕），局部变量消失，所占据的内存释放。
+ 操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面。

## 17.指针常量和常量指针有什么区别？
```cpp
const int * = &a;
int * const a = &b;

```
+ 指针常量就是指针本身是常量，换句话说，就是指针里面所存储的内容（内存地址）是常量，不能改变。但是，内存地址所对应的内容是可以通过指针改变的。

+ 常量指针就是指向常量的指针，换句话说，就是指针指向的是常量，它指向的内容不能发生改变，不能通过指针来修改它指向的内容。但是，指针自身不是常量，它自身的值可以改变，从而指向另一个常量。

## 18.typedef和define有什么区别?
+ 作用不同，typedef用于定义一种数据类型的别名，而define宏定义，展开复杂代码
+ 执行时间不同，typedef是编译的过程，有类型检查。而define发生在预处理的过程，在typedef 的前面，只做代码展开，没有类型检查。
+ 作用域不同，typedef具有作用域限定，而define没有，只要在define声明后的引用，都可以使用。

## 19.什么是野指针，如何避免野指针？
指向非法的内存地址指针叫作野指针（Wild Pointer），也叫悬挂指针（Dangling Pointer），意为无法正常使用的指针。
避免：
+ 指针必须初始化或者置为空
+ 指针指向的内存空间被释放（free或delete）后应该将指针置为空
+ 指针要指向变量作用域未结束前的变量，在变量的作用域结束前要释放掉指针所指的内存空间并将指针的指向设为空

## 20.__func__和__LINE__的实现机制是怎么样的？
这两个都是c++标准下的预定义宏。两者是在预处理阶段展开,由编译器实现。

## 21.说一说extern
+ extern置于变量或者函数前在变量或者函数之前加上extern关键字表明这是一个声明, 其定义可能在其他文件处, 注意不能对变量进行初始化或者对函数进行定义, 否则表明这是一个定义而不是声明.

+ extern "C"的目标是为了实现c++ 和 c的混合编程。加入extern "C"后，是指示编译器对指定代码以c的方式编译链接。
em: c++支持函数重载，在编译的时候函数的返回类型与函数参数类型也会加入到编译后的代码，但是c不会将函数参数类型加入。所以利用这个方法可以使得c++能够调用c语言代码。

## 22.const关键字
const关键字就是说明，对应的是常量，值不可改变。
+ const修饰变量的时候，表示不能改变他，而且要在定义的时候就完成初始化。
+ const 修饰指针，常量指针、指针常量两种方式。const int *p, 常量指针：指向常量的指针，指针所指的不能修改。int * const p, 指针常量：指针本身是常量，指针本身的地址是无法修改的。
+ const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数。
+ const修饰类成员函数的时候，成员函数是不能修改对象的数据，除非对变量加上mutable限制。
+ const修饰类对象的时候，const对象只能访问const成员函数，const成员变量，非const对象可以访问任意成员函数。 