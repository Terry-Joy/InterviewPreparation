## 1.c++内存分配方式
c++中内存分配分为5块，堆，栈，自由存储区，全局/静态存储区，常量区。
+ 堆：操作系统维护的一块特殊内存，用于程序的内存动态分配，一般用malloc分配，free释放。
+ 栈：在执行函数的时候，函数内部局部变量的存储单元都可以在栈上创建，函数结束的时候存储单元自动被释放。
+ 自由存储区：自由存储区是c++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。自由存储区是否等价于堆取决于operator new在哪里分配内存。
+ 全局/静态存储区：程序编译的时候已经分配好的，在程序整个运行期间都存在。例如全局变量、静态变量。
+ 常量存储器：特殊的存储区，里面存放的常量，无法修改。

## 2.new/delete和malloc/free之间有什么关系？
+ new/delete是操作符，malloc/free是库函数
+ new分为2步，分配内存、构造。分配内存阶段对应于malloc，但是new分配内存可以重载，自定义内存分配策略，自定义分配的位置，但是malloc只能在堆开辟。
+ new申请空间后会调用构造函数完成初始化，delete在释放内存前会调用析构函数销毁资源，但是malloc/free只会开辟和释放内存，不会调用构造函数和析构函数。
+ malloc申请空间需要手动计算空间传递，new只需要传递类型可以自动计算。
+ malloc返回的是void*，在使用的时候需要强制类型转换，new后面跟的是类型所以不用。
+ new/delete的效率比malloc/free低，因为底层封装的就是malloc/free。

## 2.delete与delete[]有什么区别？

## 4.内存泄漏场景、如何判断内存泄漏？如何定位内存泄漏？
**内存泄漏**：程序动态分配的内存，由于疏忽或错误导致未释放或者无法释放，造成系统内存的浪费。
后果：大量内存泄漏会导致程序性能下降直至内存用尽，最后程序崩溃。
**场景**：
+ malloc和free未成对,new和delete未成对，动态分配内存后未能正确释放的场景都是。
+ 未将基类的析构函数定义为虚函数（无法销毁派生类所有对象）
+ 程序因为异常未能执行异常处理操作后的内存释放操作。
linux系统下，

## 5.内存溢出是什么？
程序申请内存的时候，没有足够的内存供申请者使用。
+ 内存中加载的数据量过于庞大，一次性从数据库读出过多数据
+ 集合类中有对象的引用，使用完后未清空，无法回收。

## 6.堆和栈有什么区别？
+ 分配和管理方式不同
  + 堆是动态分配的，分配和释放由程序员控制
  + 栈由编译器自动管理，无需手动控制。
+ 管理机制
  + 堆：系统利用链表记录空闲内存地址，收到内存分配申请时，遍历链表，找到第一个满足的堆节点，维护链表，分配空间。
  + 栈：只要栈剩余内存大于申请内存，系统就会分配。
+ 碎片问题：
  + 堆：频繁的new/delete会造成内存空间的不连续，产生大量碎片，影响程序效率。
  + 栈：由于先进后出，没有碎片问题。
+ 地址增长方向不同：
  + 堆向着内存地址增加的方向增长。从内存的低地址向高地址增长。
  + 栈向着内存地址减少的方向增长。从内存的高地址向低地址增长。
+ 分配大小
  + 堆分配大小较大,windows下32位4G
  + 栈一般偏小,linux默认8m
+ 分配效率不同：
  + 栈由计算机分配，计算机在底层会对栈提供支持:分配专门的寄存器存放栈的地址,出栈入栈有专门的指令执行,效率较高.
  + 堆是动态分配的, 效率相对较低

## 7.静态内存分配和动态内存分配有什么区别？
+ 分配时间不同：静态内存分配是在编译时期完成的，不占用cpu资源。动态内存分配是在运行时期完成的，分配和释放占用CPU资源。
+ 分配空间：静态内存分配是在栈上分配的，动态内存分配是在堆上分配的。
+ 静态内存分配是按计划分配的，在编译前就确定了内存块的大小。但是动态内存分配不需要预先确定存储空间，按需分配。
+ 静态内存分配是把内存的控制权交给了编译器；动态内存分配把内存控制权交给了程序员。
+ 静态内存分配的效率比动态内存分配效率高，动态内存分配不当可能造成内存泄漏。

## 8.如何构造一个类，使得使得只能在堆上或只能在栈上分配内存？
静态建立类对象：A a 在栈上建立, 动态：A *a，在堆上建立。
在堆上建立，就是不能静态建立。
(1)只能在堆上分配类对象
+ 可以把析构函数设为私有的，（静态构建对象的时候编译器会检查所有非静态函数，假如析构函数是私有的不合法）然后利用提供一个public的destory函数来释放资源。
  （但这样无法解决继承问题，析构函数通常设为virtual，子类重写，实现多态）
+ 所以，可以把构造和析构设置为protected, 然后定义
  一个public的static A* create() {

  } 完成构造，和void destory(){
	  delete this
  }完成析构。

(2)只能在栈上分配对象
c++通过new运算符实现分配在堆上，所以我们可以重写operator new,设为私有即可
```cpp
class A
{
private:
void* operator new(size_t t){} // 注意函数的第一个参数和返回值都是固定的
void operator delete(void* ptr){} // 重载了new就需要重载delete
public:
A(){}
~A(){}
};
```
## 9.浅拷贝和深拷贝有什么区别？
+ 浅拷贝也可以称为值拷贝，在未定义显示拷贝构造函数的情况下，一般模板都是浅拷贝，完成数据成员的值的一一复制，没有指针的时候是可以的，但是有指针数据成员的话，会导致两个指针指向同一地址，析构的时候会导致指针空悬现象。
+ 深拷贝就是在堆上开辟出和源对象相同大小的空间，再拷贝数据成员，两个对象之间没有影响。

## 10.字节对齐和结构体内存对齐问题。
现代计算机读取数据都是按照内存存取粒度来的，k倍字节开始读起。有效对齐值 #pragma pack(n) 和结构体最长数据类型中长度较小的那个。
#pragma pack(n) 改变对齐系数
(1) 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。
(2) 结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。
