## 1.并发与并行
并发：多个任务在同一时间间隔内同时发生，这里的同时发生其实是一种假象，一般指通过上下文切换，CPU执行进程一段时间后，切换到另一个进程执行，继续下去，由于切换的速度较快，从宏观上看起来多个进程好像同时运行。
并行：多个任务在同一时刻发生。一般在多核CPU或者单核多核心CPU上发生，每个CPU在同一时刻各自运行自己的进程。
并发的多个任务是在同一实体上执行的，所以互相抢占资源。但并行是不同实体上的多个任务，所以互相不抢占资源。

## 1. 2 什么是用户态和内核态？
为了限制不同程序之间的访问能力，一般操作系统对进程执行权限进行分级，分别为用户态和内核态。(设置时钟、内存清理，假如随意进行这些操作，系统容易崩溃)
+ 用户态：处于用户态的进程对于内存的访问是受限的，并且不允许直接访问外围设备。同时进程的CPU也可以被其他程序获取。
+ 内核态：处于内核态的进程几乎可以访问计算机的任意资源，包括外围硬件设备等等， 而且内核态的进程占用CPU的时候不会发生抢占情况，一般特权级为0的称为内核态。


## 1.3 什么是系统调用？
系统调用就是指用户在程序中向操作系统的内核请求需要更高权限运行的服务。系统调用本质上提供了内核与用户程序的接口。系统中的共享资源是由操作系统掌管的，所以在用户程序中，假如需要进行存储分配，I/O传输等操作的时候，都需要通过系统调用的方式向操作系统提出服务请求，并由操作系统代为完成。

系统调用按功能大致可分为如下几类：

+ 设备管理。完成设备的请求或释放，以及设备启动等功能。
+ 文件管理。完成文件的读、写、创建及删除等功能。
+ 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
+ 进程通信。完成进程之间的消息传递或信号传递等功能。
+ 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

## 1.4 如何从用户态切换到内核态呢
+ 系统调用
这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如 read 操作，比如前例中 fork() 实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。
+ 异常(缺页异常)
当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
+ 外围设备的中断
当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。**比如硬盘读写操作完成，向CPU发出中断信号，系统会切换到硬盘读写的中断处理程序中执行后续操作等。**

## 3.什么叫临界区
每个进程中对共享内存进行访问的程序片段就叫临界区。每次只允许一个进程进入临界区，进入后不允许其他进程进入。

## 4.同步、异步、阻塞、非阻塞的概念
同步：发出同步调用之后，调用者需要一直等待结果而无法执行后续操作，只有得到通知后，才能进行后续的执行。
异步：异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。
+ 状态
即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。
+ 通知
当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。
+ 回调
与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。

阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

非阻塞：非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

## 5.进程、线程、协程的基本概念
进程：程序的一次执行过程，它是操作系统进行资源分配和管理的基本单位，同时也是系统中并发执行的单位。

线程：是进程的一个实体，同时也是操作系统进行运行调度的最小单位。有时也被成为轻量级进程。

协程：协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。
协程的好处在于
+ 没有线程上下文切换的开销
+ 不加锁的访问全局变量。
  协程是异步机制。

**重要**
+ 协程是非抢占式多任务，线程是抢占式多任务。
+ 协程需要编写代码者主动让出控制权，而线程可以无需规划让出控制权的时间点。
+ 协程哪怕没有操作系统干预也可以实现，毕竟任何编程语言自身就能够实现这个结构。早期的多任务大多来自于此。所以协程肯定是早于线程出现的。
+ 最初，抢占式多任务的发明是一个feature，不需要考虑程序在何处被插入，就可以自动的实现多任务。很多人觉得这很方便。然而后来，线程的弊端慢慢显现，一方面是程序不知道在什么时间点会被抢走焦点因此无法更有效的规划数据访问，二方面是线程需要有额外开销，有大量并行任务时不适合使用线程，例如C10K问题需要在短时间内响应一万个请求，而当时的系统尚不能有效处理一万个线程。于是，协程重新回到了程序员的视线。因为一方面，
+ 协程代码中所有让出控制权的结点都是已知的，不会存在多线程同步方面的相关问题。二方面，协程的开销非常小，成千上万个协程并发也完全没问题。

## 6.进程与线程的区别
+ 进程是资源管理和分配的基本单位，线程是操作系统进行运行调度的基本单位。
+ 地址空间：线程共享本进程的地址空间，但进程之间是独立的地址空间，所以一个进程是无法看到另一个进程内的线程的。
+ 资源：线程共享本进程的资源，比如内存、I/O，CPU，但是进程间资源是独立的。
+ 健壮性：进程之间是独立的，一个进程崩溃后，在保护模式下(CPU一种模式，增强系统稳定度，提供内存保护)不会对其他进程产生影响，但是一个线程崩溃后，可能导
(严格的说没有“线程崩溃”，只是触发了SIGSEGV (Segmentation Violation/Fault)。如果没有设置对应的Signal Handler操作系统就自动终止进程（或者说默认的Signal Handler就是终止进程）；如果设置了，理论上可以恢复进程状态继续跑（用longjmp之类的工具）)
+ 上下文资源切换效率：进程上下文切换的时候，要切换用户地址空间(程序代码、数据、用户堆栈)，还要切换内核栈、寄存器、程序计数器等内核资源，这种切换会导致原来CPU中的缓存失效（TLB），一段时间内的内存访问效率降低，而线程上下文切换的时候切换内核栈、少量寄存器，所以线程切换开销远比进程小。
+ 同理线程创建销毁开销也比进程要小。
  
## 7.既然有了进程，为什么还要线程呢？
进程使得多个程序并发执行，提高资源的利用率和系统的吞吐量。但是带来了一些缺点。
+ 进程同一时间只能干一件事。
+ 多进程模型中，进程间具有不同的地址空间，所以无法实现并行实体共享同一地址空间和可用数据的能力。这样会导致一些问题，比如一个进程阻塞了，整个进程都会挂起，即便进程中有些工作不依赖于等待的资源。
+ 所以，操作系统引入了更轻量的线程作为CPU调度的单位。他有以下优势。
+ 从资源开销来讲，线程比进程更加轻量。比如创建一个新的进程需要分配给它独立的地址空间，但线程不用，他的创建和销毁的开销更低。
+ 从通信角度来讲，线程间通信比较方便。对于不同进程来说，他们具有独立的数据空间，数据传输需要通过进程间通信的方法来传递，费时且不太方便，但线程共享同样的数据空间，所以数据可以直接为其他线程使用，快捷方便。
+ 进程中会存在多种活动任务，只有进程的话，当其中一个任务阻塞的时候，别的任务无法进行。所以可以通过多个独立调度的单元分别执行这些任务，也就是线程。

## 用户级线程和内核级线程


## 8.进程有哪几种状态，状态转换
主要是三种状态，就绪状态、运行状态、阻塞状态。
[![bD3rSH.md.png](https://s1.ax1x.com/2022/03/06/bD3rSH.md.png)](https://imgtu.com/i/bD3rSH)
[![bD3gmt.md.png](https://s1.ax1x.com/2022/03/06/bD3gmt.md.png)](https://imgtu.com/i/bD3gmt)


## 9.进程间通信方式
+ 管道
实际上是一个内核缓冲区，进程按照先进先出的方式从内核缓冲区读写数据，数据是无格式的字节流。有以下特点
  + 半双工通信，数据只能往一个方向流动，如果双方都能读写的话，就需要建立两个管道
  管道有两种管道：
  + 匿名管道：linux里面的|就是匿名管道的使用，除了单向传输这个特点外，还有就是管道只能在具有亲属关系的进程间使用，比如说父子进程或者兄弟进程。它可以看成是一种特殊的文件，采用read或者write读写，但是它不在文件系统中，只存在于内存中。
  + 命名管道：一般用mkfifo创建。和匿名管道相比：(1)一般可以在无关进程间使用。因为它有路径名和它相关联，是以一种特殊设备文件形式存在于文件系统中的。(mkfifo name)

坏处：
**管道通信效率低，不适合频繁交换数据，缓冲区大小受限、数据是无格式字节流**

+ 消息队列
保存在内核中的消息的链表，假如进程a要向b发送信息的时候，只需要往消息队列中添加信息就可以了，读取的时候就从消息队列读取信息。
  + 消息队列面向记录的，其中消息有特定的格式和优先级。
  + 消息队列独立于发送与接收进程的。当进程终止时，消息队列不会消失，但管道机制会。
  + 消息队列的查询不用按照先进先出的方式，可以自定义条件接收特定类型的消息。
  **缺点**：
  + 不适合太大的消息传递，内核中的消息体是有大小限制的。同时消息队列也有大小限制的。（内核有变量定义）
  + 不适合频繁的数据运输，因为消息队列是存储在内核的，频繁数据传输在用户态和内核态之间，开销很大。
+ 共享内存：进程之间拿出一块虚拟内存空间，映射到同样的物理内存上。这样可以避免数据间的多次拷贝，速度是最快的。
  + 但由于进程是直接访问内存的，可以多个进程对共享内存同时操作，所以需要进程对内存的访问是互斥的，也就引出了信号量。
+ 信号量：
	+ 整型的计数器，用于实现进程的同步与互斥, 搭配共享内存机制可以完成进程间通信.
	+ 操作系统通过P和V两种原子操作来对信号量进行控制.
	+ P 操作：将 sem 减 1 ，相减后，如果 sem < 0 ，则进程/线程进⼊阻塞等待，否则继续，表明 P操作可能会阻塞；
	+ V 操作：将 sem 加 1 ，相加后，如果 sem <= 0 ，唤醒⼀个等待中的进程/线程，表明 V 操作不会阻塞；
+ 信号: 信号是一种比较复杂的通信方式，用于通知进程某个事件已经发生。linux为了响应各种事件, 提供了很多信号, 用kill -l查询到, 比如ctrl+C, 就是发出一个终止进程的信号, ctrl+Z就是挂起该进程.
+ socket: 与其他通信机制不同的是，它可用于不同机器间的进程通信。

## 10.进程间同步的方式?
+ 临界区
首先对临界资源的访问那段代码被称为临界区，为了互斥的访问临界区，每个进程在进入临界区时，都需要先进行检查，也就是查看锁。

+ 同步与互斥
同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后顺序。
互斥：多个进程在同一时刻只有一个进程能进入临界区。

+ 信号量
信号量是一个整型计数器，可以对其执行 P 和 V 操作。
通过PV原子操作控制.
P 操作：将 sem 减 1 ，相减后，如果 sem < 0 ，则进程/线程进⼊阻塞等待，否则继续，表明 P操作可能会阻塞；
V 操作：将 sem 加 1 ，相加后，如果 sem <= 0 ，唤醒⼀个等待中的进程/线程，表明 V 操作不会阻塞；

+ 管程
使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。
管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。
管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对 条件变量 执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

## 11.进程调度算法
**1. 批处理系统**
批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

+ 先来先服务 first-come first-serverd（FCFS）

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

+ 最短作业优先 shortest job first（SJF）

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

+ 最短剩余时间优先 shortest remaining time next（SRTN）

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

## 2. 交互式系统
交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

+ 时间片轮转
将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
而如果时间片过长，那么实时性就不能得到保证。

+ 优先级调度

为每个进程分配一个优先级，按优先级进行调度。优先级可以是静态分配也可以由系统动态决定。

为了防止低优先级的进程永远等不到调度而饿死，可以随着时间的推移增加等待进程的优先级。

+ 多级反馈队列

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

**3. 实时系统**
实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

## 12. 三个经典问题（会写伪代码）

## 13. 什么是死锁？
死锁指多个进程或者线程因为争夺资源而产生的一种僵局，处于死锁状态的时候，若无外力作用，它们将无法再向前推进。如下图所示：如果此时有一个线程 A，已经持有了了锁 A，但是试图获取锁 B，线程 B 持有
锁 B，⽽试图获取锁 A，这种情况下就会产生死锁。
[![bshx8f.png](https://s1.ax1x.com/2022/03/07/bshx8f.png)](https://imgtu.com/i/bshx8f)


## 14. 讲讲死锁发生的必要条件是什么？
+ 互斥条件：是资源分配是互斥的，资源要么处于被分配给一个进程的状态，要么就是可用状态。
+ 持有并等待：进程在请求资源得不到满足的时候，进入阻塞等待状态，且不释放已占有的资源。
+ 不剥夺条件：已经分配给一个进程的资源不能强制性地被抢占，只能等待占有他的进程释放。
+ 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程释放所占有的资源。

## 15. 怎么解决死锁问题
+ 预防死锁（破坏四个必要条件）
  + 破坏互斥条件：比如只读文件、磁盘等软硬件资源可采用这种办法处理。
  + 破坏占有和等待条件：在进程开始执行之前，请求所需的所有资源，如果所需的全部资源可用，才分配给它并执行，否则让它等待。
  + 破坏不剥夺条件：允许进程强行从资源占有者那里夺取某些资源
  + 破坏环路等待条件：给系统的所有资源编号，规定进程请求所需资源的顺序必须按照资源的编号依次执行。

+ 避免死锁
  + 安全状态、银行家算法具体看256～258

+ 死锁检测（等死锁发生了再检测，检测后再恢复）
  + 每种类型只有一个资源的死锁检测，画图、dfs或者拓扑排序。
+ 死锁恢复
  + 资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程（但应该防⽌止被挂起的进程⻓时间得不到资源）；
  + 撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进
程代价的⾼低进行）；
  + 进程回滚：让一个或多个进程回退到⾜以避免死锁的地步。进程回退时⾃愿释放资源⽽不是被剥夺。要求系统保持进程的历史信息，设置还原点。

## 16.举出死锁的例子
A线程占据资源A请求B，B线程占据资源B请求A，都不释放。

生产者消费者模型：对临界区的上锁如果放在了检测缓冲区是否已经满之前，就有可能发生死锁。比如生产者此时要产生一个产品，如果先对临界区上锁，然后检测缓冲区已满，这时就进入等待消费者消耗产品的状态，而消费者想消费产品时，必须先检测临界区是否上锁，此时临界区已经被生产者占有，这样就形成了死锁。

## 17.分页与分段的区别？
+ 段是信息的逻辑单位，是根据用户的需求划分的，(比如堆栈段、代码段)，所以段对用户是可见的。但是页是信息的物理单位，是为了管理内存方便划分的，所以对用户是不可见的。
+ 段的大小是不固定的，根据需要来分配。但是页的大小是固定的，由操作系统决定。
+ 页向用户提供的是一维的地址空间，只需要一维即可确定。但是段向用户提供的是二维的地址空间，既要给出段名，又要给出段内地址。
+ 通过分段机制，可以很容易实现过程和数据间的共享以及保护。但是分页机制很难实现。


## 18.物理地址、逻辑地址。
+ 逻辑地址是应用程序看到的地址，由CPU生成，一般指的是相对于应用程序自己的地址。比如说访问指令给出的地址，就是逻辑地址。一般都要通过地址映射转换成物理地址。
+ 物理地址：地址转换的最终地址，内存单元的绝对地址。
  
## 19.谈谈虚拟内存 (why + how)
虚拟内存是一种内存管理机制，他的目的是为了让物理内存扩充成更大的逻辑内存，使得程序获得更多可用内存。它的本质是对于每一个程序，抽象出一个属于自己的连续的虚拟地址空间，该地址空间被分割成多个块，每块被称为一页。每页都有连续的地址范围，有些页被映射到实际的物理内存上，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。这种抽象使得程序只需要关注自己的虚拟地址空间即可，方便了内存管理。

## 20.页面置换算法
答：当使用请求分页存储来管理内存时，发生缺页中断，就是要访问的页面不在内存中，这时就需要操作系统把其调入主存后再进行访问。
而在发生缺页中断时，并且内存中没有空闲的页面，就必须在内存中根据一定的策略挪出一些不用的页面，可以把页面置换算法看成是淘汰机制。
+ 最优页面置换算法（OPT): 未来最少使用的换掉，无法实现
+ FIFO 先进先出：把在内存中停留时间最长的页面置换出去
+ LRU 最近最久未使用页面置换算法：LRU 算法赋予每一个页面一个访问字段，来记录一个页面最近一次访问到现在所经历的时间 T，需要淘汰一个页面时，把最久没有使用的页面淘汰掉就可以了。
+ 时钟页面置换算法：算法为每个⻚面设置⼀位访问位，将内存中的所有⻚面都通过链接指针链成⼀一个循环队列。
  如果它的访问位位是 0 就淘汰该⻚⾯，并把新的⻚⾯插⼊这个位置，然后把表针前移⼀个位置；
如果访问位是 1 就清除访问位，并把表针前移⼀个位置，重复这个过程直到找到了⼀个访问位为 0 的
⻚⾯为⽌；

## 21.谈谈你对动态链接库和静态链接库的理理解？
+ 静态链接就是在编译链接时直接将需要的执行代码拷⻉到调用处，优点就是在程序发布的时候就不需要依赖库，
程序可以独⽴执行，但是程序的体积可能会相对⼤一些。

+ 动态链接就是在编译的时候不直接拷⻉可执⾏代码，⽽是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享 执⾏内存中已经加载的动态库可执行代码，最终达到运行时链接的⽬的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的执行性能。

## 22.外中断和异常有什么区别
+ 外中断指由CPU指令以外的事件引起，如I/O完成中断,当输入输出处理已经完成, 通过中断告诉进程, 还有时钟中断, 控制台中断.
+ 异常是由于CPU执行指令的内部事件引起，如非法操作码、地址越界.

## 23.程序从开始运行到结束的过程, 你能说出多少
一个程序从开始运行到结束的完整过程，你能说出来多少？
四个过程：
+ 预编译
  
主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下
1、删除所有的#define，展开所有的宏定义。
2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。
3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他
文件。
4、删除所有的注释，“//”和“/**/”。
5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重
复引用。
6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是
能够显示行号。

+ 编译
  
把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相
应的汇编代码文件。
1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分
割成一系列的记号。
2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的
语法树是一种以表达式为节点的树。
3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进
行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定
的语义。
4、优化：源代码级别的一个优化过程。
5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语
言表示。
6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移
来替代乘法运算、删除多余的指令等。

+ 汇编
将汇编代码转变成机器可以执行的指令(机器码文件)，生成目标文件.o

汇编器的汇编过程相对于编译器来说更简单，没
有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过
来，汇编过程有汇编器as完成。
经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux下)、xxx.obj(Windows下)。

+ 链接
将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链
接：
  + 静态链接：
会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。

函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库
中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个
目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，
在执行的时候运行速度快。
  + 动态链接：
动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，

在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副
本，而是这多个程序在执行时共享同一份副本；
更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运
行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损
失。

## 24.什么是守护进程、孤儿进程、僵尸进程
+ 守护进程
在后台运行的服务进程，没有控制终端与之相连，周期性地执行某种任务。同时也是个特殊的孤儿进程。linux大多服务器就是用守护进程实现的，syslogd管理日志系统的守护进程, web服务器httpd.

(之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。)

用户层守护进程是init进程。

+ 进程组 ：每个进程除了有一个进程ID之外，还属于一个进程组进程组是一个或多个进程的集合，同一进程组中的各进程接收来自同一终端的各种信号，每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID会话
<br>
+ 会话（session）是一个或多个进程组的集合， 进程调用 setsid 函数建立一个新会话，如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话(如果是的话就出错)。具体会发生以下3件事：
  + 该进程变成新会话的会话首进程（session leader，会话首进程是创建该会话的进程）。此时，该进程是新会话的唯一进程。
  + 该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID
  + 该进程没有控制终端。如果调用setsid之前该进程有一个控制终端，那么这种联系也被切断

编写守护进程：
+ 屏蔽一些控制终端操作的信号，防止守护进程没有运行起来前，控制终端受干扰退出
+ 后台运行(为避免挂起控制终端，守护进程放后台运行，fork()后终止父进程)
+ 脱离控制终端、登陆会话、进程组(会话->多个进程组，所有进程组共享一个s控制终端) 
  setsid()调用后，本身就属于一个新的会话组长和进程组组长。(通过fork()防止PPID为其本身)
+ 禁止进程重新打开控制终端。再次fork(), 第二子进程将不会是session组长
+ 关闭打开文件描述符
+ 改变当前工作目录。进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如 /tmp。
+ 重设文件创建掩模
+ 处理SIGCHLD信号。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源.如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在 Linux 下可以简单地将 SIGCHLD 信号的操作设为 SIG_IGN 。
<br>
+ 孤儿进程
  一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

+ 僵尸进程
子进程先退出，父进程还没退出，子进程必须等待父进程捕获到子进程退出并回收PCB等资源才算真正退出。若父进程没有回收，则子进程变成僵尸进程。

## 25.**如何避免僵尸进程**？
<br>
当一个子进程终止时，会发送SIGCHLD信号

+ 父进程调用wait()或者waitpid()等待子进程结束，但是前者会阻塞直到有子进程结束。
+ 父进程不关心子进程何时结束的时候，可以使用
	signal(SIGCHLD, SIG_IGN), 父进程会忽略该信号，由内核进程回收(init进程回收)
+ 通过两次调用fork。⽗进程⾸先调⽤用fork创建⼀个子进程然后waitpid等待子进程退出，⼦进程再fork⼀个孙进程后退出。这样⼦进程退出后会被⽗进程等待回收，⽽对于孙⼦进程其父进程已经退出所以孙进程成为⼀个孤儿进程，孤⼉进程由init进程接管，孙进程结束后，init会等待回收.
+ 如果父进程很多事情处理无法wait或者waitid，我们可以signal函数注册信号处理函数，子进程自动退出的时候会回调信号处理函数，里面用wait或者waitid处理。

## 26.进程终止的方式
+ 正常退出（自愿
  + 任务完成，比如编译器完成了编译任务后，执行系统调用告诉系统。unix下exit
+ 错误退出（自愿
  + 编译错误，编译文件不存在
+ 严重错误（非自愿
  + 访问非法内存，除数为0，进程被中断。
+ 被杀死（非自愿
  + kill

## 27. 内存交换中，被换出的进程保存在哪里？
保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把磁盘空间分为⽂件区和对换区两部分。⽂件区主要用于存放文件，主要追求存储空间的利用率，因此对⽂件区空间的管理采⽤用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采⽤用连续分配方式(学过⽂文件管理理章节后即可理理解)。总之，对换区的I/O速度⽐文件区的更快。

## 28.什么叫抖动、颠簸？
刚换出的⻚面⻢上⼜要换入内存，刚换入的⻚面⻢上⼜要换出外存，这种频繁的⻚面调度⾏为称为抖动，或颠
簸。
1-如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；

2-如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量。

3-否则，还剩下两个办法：1终止该进程；2增加物理内存容量；

https://gitee.com/wx_98fa5ee790/chat.git

## 29.linux虚拟内存分区
从低地址到高地址分别是代码段、已初始化的数据段，未初始化的数据段，堆、未分配的内存，栈、内核空间。

1. 代码段（Text Segment）
代码段存放程序执行代码的一段内存区域，这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读（不过某些架构也允许修改程序）。代码段中的指令包括操作码和被操作对象（或对象地址引用）。

只读变量：只包含在代码段中
局部变量：在栈区分配内存空间并引用
全局变量：引用BSS段或Data段中的地址
2. 数据段（Data Segment）
静态内存分配，存放静态变量、初始化的全局变量和常量。

3. Block Started by Symbol（BSS Segment）
静态内存分配，包含了程序中未初始化的全局变量，在内存中BSS段全部置为零。

4. 堆（heap）
动态内存分配，当进程调用malloc等函数分配内存时，堆会扩张用于存放新申请的变量，使用free等函数释放内存时，被释放的内存从堆中删除。

5. 栈（stack）
存放函数的局部变量（即在函数括弧{}中定义的变量），除此之外在函数被调用时参数也会被压入栈中，函数调用结束后函数的返回值也会被存放在栈中。

另外，栈具有后进先出的特点，经常用于保存/恢复调用现场，这也是我们在程序crash时打印stack的原因。

## 30.C++程序的内存分配
一个由C/C++编译的程序占用的内存分为如下几个部分：

+ 栈区（stack）：由编译器自动分配释放，存放函数的参数值、局部变量值等，其操作方式类似于数据结构中的栈（后进先出）
+ 堆区（heap）：由程序员分配释放，若程序员不释放则程序结束时可能由操作系统回收，注意它与数据结构中的堆不一样，分配方式倒是类似于链表
+ 全局区/静态区（static）：全局变量和静态变量的存储时放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由操作系统释放
+ 常量存储区：存放不允许修改的常量（不过也可以通过非正当手段修改）
+ 程序代码区：存放函数体的二进制代码
