多线程

+ 多线程的几种锁
锁的目的：防止多线程访问共享资源的时候，因为资源竞争导致数据错乱。所以我们在访问共享资源前，通常会先加锁。
  + 悲观锁
    + 互斥锁
		互斥锁是一种独占锁，一方获得后，另一方不能获得，所以加锁失败后，线程会让出CPU，挂起。这部分主要是由操作系统内核实现。互斥锁在加锁失败的时候会有两次线程上下文切换的成本。第一次是加锁失败，被挂起，把CPU切换给其他线程。第二次就是当锁被释放的时候，在合适的时间的时候，内核会唤醒这个线程，把CPU切换给该线程运行。上下文切换的时间在几十纳秒到几微秒之间，假如锁住代码的执行时间比较短，那么可能上下文切换时间比执行代码的时间还长，这个时候就应该用自旋锁。
    + 自旋锁
		**自旋锁是通过CPU提供的CAS函数完成的，在用户态就完成加锁解锁操作，CAS把观察锁和占有锁合成原子指令，要么一次性执行完，要么两个步骤都不执行。** 使用自旋锁的时候，当多线程竞争锁的时候，加锁失败的时候线程会进入轮询忙等待状态直至获取锁。在单核 CPU 上，需
要抢占式的调度器（即不断通过时钟中断⼀个线程，运⾏其他线程）。否则，⾃旋锁在单 CPU 上⽆法使⽤，因为⼀个⾃旋的线程永远不会放弃 CPU。（）)。自旋锁一般不会主动进行线程上下文切换，但是等待的时间和被锁住的代码执行时间有关，所以假如执行代码的时间比较短，我们可以使用自旋锁。
    + 读写锁
		分为读锁和写锁，一般适用于明确区分读写操作的场景。原理是当写锁没有被线程占有的时候，多个读锁可以并发持有读锁，并发读取共享资源。
		但是当写锁被线程占有后，读线程获取读锁的操作会被阻塞，同时写线程获取写锁的操作也会被阻塞。所以读锁可以被多个线程拥有，而写锁只能被一个线程占有。
		设计的策略可以分为读优先锁，写优先锁。
		+ 读优先锁就是希望读锁可以被更多线程占有，假如线程A持有读锁，线程B申请写锁的时候会被阻塞，在线程B阻塞的时候，后续线程可以成功获取读锁。只有等读锁释放后，线程B才可以获取写锁。
		+ 写优先锁，就是假如A获取读锁，B获取写锁的时候阻塞，后续来了C获取读锁，C会被阻塞，为了让B优先获取写锁。但是两者的问题都是饿死。
		+ 公平读写锁：⽤队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先
出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。
  + 乐观锁
  悲观锁做事⽐较悲观，它认为多线程同时修改共享资源的概率⽐较⾼，于是很容易出现冲突，所以访问共
享资源前，先要上锁。
  乐观锁做事⽐较乐观，它假定冲突的概率很低，它的⼯作⽅式是：先修改完共享资源，再验证这段时间内
有没有发⽣冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资
源，就放弃本次操作。

服务端要怎么验证是否冲突了呢？通常⽅案如下：
+ 由于发⽣冲突的概率⽐较低，所以先让⽤户编辑⽂档，但是浏览器在下载⽂档时会记录下服务端返回
的⽂档版本号；
+ 当⽤户提交修改时，发给服务端的请求会带上原始⽂档版本号，服务器收到后将它与当前版本号进⾏
⽐较，如果版本号⼀致则修改成功，否则提交失败。

Git 也是⽤了乐观锁的思想，先让⽤户编辑代码，然后提交的时候，通过版本号来判断是否产⽣了冲突，发⽣了冲突的地⽅，需要我们⾃⼰修改后，再重新提交。乐观锁虽然去除了加锁解锁的操作，但是⼀旦发⽣冲突，重试的成本⾮常⾼，所以只有在冲突概率⾮常低，且加锁成本⾮常⾼的场景时，才考虑使⽤乐观锁。 	

	